# -*- coding: utf-8 -*-
"""ipl.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HZ7_N_yJn-bBXum-hWi6dpw7h8k1kZcy

##                                                    IPL Match Winning Predictor

Name : Utkrist Ark
Registration No. :- 12105798
Section :- K21UN
"""



import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

delivery = pd.read_csv('deliveries.csv')
match = pd.read_csv('matches.csv')

match.head()

match.shape

delivery.head()

total_score_df =delivery.groupby(['match_id','inning']).sum()['total_runs'].reset_index()

total_score_df = total_score_df[total_score_df['inning']==1]

match_df =match.merge(total_score_df[['match_id','total_runs']],left_on='id',right_on='match_id')

match_df['team1'].unique()





"""This code is for preprocessing cricket match data. It replaces outdated team names like "Deccan Chargers" with "Sunrisers Hyderabad" and "Delhi Daredevils" with "Delhi Capitals". Then it filters the match data to include only matches between the specified teams: Sunrisers Hyderabad, Mumbai Indians, Royal Challengers Bangalore, Kolkata Knight Riders, Kings XI Punjab, Chennai Super Kings, Rajasthan Royals, and Delhi Capitals."""

teams =[
    'Sunrisers Hyderabad', 'Mumbai Indians','Royal Challengers Bangalore','Kolkata Knight Riders','Kings XI Punjab',
    'Chennai Super Kings', 'Rajasthan Royals', 'Delhi Capitals'
]
match_df['team1']=match_df['team1'].str.replace('Deccan Chargers','Sunrisers Hyderabad')
match_df['team2']=match_df['team2'].str.replace('Deccan Chargers','Sunrisers Hyderabad')

match_df['team1']=match_df['team1'].str.replace('Delhi Daredevils','Delhi Capitals')
match_df['team2']=match_df['team2'].str.replace('Delhi Daredevils','Delhi Capitals')
match_df = match_df[match_df['team1'].isin(teams)]
match_df = match_df[match_df['team2'].isin(teams)]

match_df['team1'].unique()



match_df.head()

match_df = match_df[match_df['dl_applied']==0]



match_df = match_df[['match_id','city','winner','total_runs']]

delivery_df =match_df.merge(delivery,on='match_id')

delivery_df =delivery_df[delivery_df['inning']==2]

delivery_df.head()

delivery_df['current_score']=delivery_df.groupby('match_id')['total_runs_y'].cumsum()

delivery_df['runs_left'] = delivery_df['total_runs_x']-delivery_df['current_score']+1

delivery_df['balls_left']=126-(delivery_df['over']*6+delivery_df['ball'])

delivery_df.head()

delivery_df['player_dismissed']=delivery_df['player_dismissed'].fillna(0)
delivery_df['player_dismissed']=delivery_df['player_dismissed'].apply(lambda x : x if x ==0  else 1)

wickets = delivery_df.groupby('match_id')['player_dismissed'].cumsum().values

delivery_df['wickets']=10- wickets

delivery_df.head()

delivery_df['crr']=delivery_df.current_score*6/(120-delivery_df.balls_left)

delivery_df['rrr']=delivery_df.runs_left*6/delivery_df.balls_left

delivery_df = delivery_df.reset_index()



delivery_df.drop(columns='index',inplace=True)



"""This function determines if the batting team won a match based on the input DataFrame 'df'. It iterates through each row of the DataFrame, comparing the 'winner' and 'batting_team' columns. If they match, it appends 1 to the 'winner' list; otherwise, it appends 0. Finally, it returns the 'winner' list, indicating whether each match resulted in a win for the batting team (1) or not (0)."""

def is_win(df):
    winner = []
    for item,row in df.iterrows():
        if row.winner == row.batting_team:
            winner.append(1)
        else:
            winner.append(0)

    return winner

delivery_df['winner']=is_win(delivery_df)

final_df =delivery_df[['match_id','batting_team','bowling_team','city','runs_left','balls_left','wickets','total_runs_x','crr','rrr','winner']]

final_df =final_df.sample(final_df.shape[0])

final_df['batting_team']=final_df['batting_team'].str.replace('Deccan Chargers','Sunrisers Hyderabad')
final_df['bowling_team']=final_df['bowling_team'].str.replace('Deccan Chargers','Sunrisers Hyderabad')

final_df['batting_team']=final_df['batting_team'].str.replace('Delhi Daredevils','Delhi Capitals')
final_df['bowling_team']=final_df['bowling_team'].str.replace('Delhi Daredevils','Delhi Capitals')

print(final_df.city.unique())
print(final_df.batting_team.unique())



"""This code assigns cities to cricket match data where the city information is missing. It first creates a dictionary mapping teams to their respective cities. Then, it defines a function 'fill_city' to fill missing city values. If the city is missing (marked as 0), it randomly selects either the batting or bowling team and assigns the corresponding city. Otherwise, it keeps the existing city value. Finally, it applies this function to the DataFrame column 'city'."""

import random
cities_dict = {
    'Royal Challengers Bangalore':'Bengaluru',
    'Chennai Super Kings':'Chennai',
    'Kings XI Punjab':'Mumbai',
    'Kolkata Knight Riders':'Kolkata',
    'Delhi Capitals':'Delhi',
    'Rajasthan Royals':'Jaipur',
    'Mumbai Indians':'Mumbai',
    'Sunrisers Hyderabad':'Hyderabad',
}
final_df['city']=final_df['city'].fillna(0)
def fill_city(x):
    if x.city == 0:
        team = [x.batting_team,x.bowling_team][random.randint(0,1)]
        return cities_dict[team]
    else :
        return x.city


final_df['city']=final_df.apply(fill_city,axis=1)

final_df.dropna(inplace=True)
final_df =final_df[final_df.balls_left !=0]



"""This code segment imports the necessary functions from sklearn for splitting data into training and testing sets. It separates features (X) from the target variable (y) and then creates training and testing sets with a ratio of 80:20, preserving the random state for reproducibility."""

from sklearn.model_selection import train_test_split
X = final_df.drop(columns=['winner','match_id'])
y = final_df['winner']
X_copy =final_df.drop(columns=['winner'])
X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2,random_state=1)



"""This code performs linear regression on cricket match data to predict the margin of victory (win by runs). It preprocesses the data by encoding categorical variables, splits it into training and testing sets, then fits a linear regression model. Finally, it evaluates the model's performance using mean squared error and prints the result."""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

df = pd.read_csv("matches.csv")
df_encoded = pd.get_dummies(df[['city', 'team1', 'team2', 'toss_winner', 'toss_decision', 'venue']])
df_processed = pd.concat([df[['win_by_runs', 'win_by_wickets']], df_encoded], axis=1)
X = df_processed.drop(columns=['win_by_runs'])
y = df_processed['win_by_runs']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
model = LinearRegression()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error:", mse)

# deliveries CSV
df = pd.read_csv("deliveries.csv")
selected_features = ['inning', 'over', 'ball', 'is_super_over', 'wide_runs', 'noball_runs', 'batsman_runs']
X = df[selected_features]
y = df['total_runs']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
model = LinearRegression()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error:", mse)

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Load the deliveries dataset
df = pd.read_csv("deliveries.csv")

# Selecting relevant features
selected_features = ['inning', 'over', 'ball', 'is_super_over', 'wide_runs', 'noball_runs', 'batsman_runs']
df_selected = df[selected_features]

# Plotting settings for Jupyter Notebook
# %matplotlib inline

# Draw pairplot
sns.pairplot(df_selected)
plt.show()

import pandas as pd
from sklearn.model_selection import train_test_split

# Load the deliveries dataset
df = pd.read_csv("deliveries.csv")

# Selecting relevant features and target variable
selected_features = ['inning', 'over', 'ball', 'is_super_over', 'wide_runs', 'noball_runs', 'batsman_runs']
X = df[selected_features]
y = df['total_runs']

# Split the data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Check the shape of the splits
print("Shape of X_train:", X_train.shape)
print("Shape of X_test:", X_test.shape)
print("Shape of y_train:", y_train.shape)
print("Shape of y_test:", y_test.shape)





from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from sklearn.ensemble import RandomForestClassifier

"""This code snippet prepares categorical data for machine learning models. It first initializes a OneHotEncoder and fits it to the first three columns of the feature data (X). Then, it extracts the categories of the encoded features. Lastly, it sets up a ColumnTransformer to apply OneHotEncoding to specific columns while leaving others unchanged (passthrough)."""

ohe = OneHotEncoder()
ohe.fit_transform(X.iloc[:,:3])
category = ohe.categories_
trf = ColumnTransformer([
    ('trf',OneHotEncoder(categories=category,sparse=False,drop='first'),['batting_team','bowling_team','city'])
],remainder='passthrough')

pipe = Pipeline([
    ('step1',trf),
    ('step2',LogisticRegression(solver='liblinear'))
#     ('step2',RandomForestClassifier(n_jobs=-1))
])
pipe.fit(X_train,y_train)

y_pred = pipe.predict_proba(X_test)
# accuracy_score(y_test,y_pred)
y_pred

def match_progression(x_df,match_id,pipe):
    match = x_df[x_df['match_id'] == match_id]
    match = match[(match['ball'] == 6)]
    temp_df = match[['batting_team','bowling_team','city','runs_left','balls_left','wickets','total_runs_x','crr','rrr']].dropna()
    temp_df = temp_df[temp_df['balls_left'] != 0]
    result = pipe.predict_proba(temp_df)
    temp_df['lose'] = np.round(result.T[0]*100,1)
    temp_df['win'] = np.round(result.T[1]*100,1)
    temp_df['end_of_over'] = range(1,temp_df.shape[0]+1)

    target = temp_df['total_runs_x'].values[0]
    runs = list(temp_df['runs_left'].values)
    new_runs = runs[:]
    runs.insert(0,target)
    temp_df['runs_after_over'] = np.array(runs)[:-1] - np.array(new_runs)
    wickets = list(temp_df['wickets'].values)
    new_wickets = wickets[:]
    new_wickets.insert(0,10)
    wickets.append(0)
    w = np.array(wickets)
    nw = np.array(new_wickets)
    temp_df['wickets_in_over'] = (nw - w)[0:temp_df.shape[0]]

    print("Target-",target)
    temp_df = temp_df[['end_of_over','runs_after_over','wickets_in_over','lose','win']]
    return temp_df,target

temp_df ,target =match_progression(delivery_df,513,pipe)

import matplotlib.pyplot as plt
plt.figure(figsize=(18,8))
plt.plot(temp_df['end_of_over'],temp_df['wickets_in_over'],color='yellow',linewidth=3)
plt.plot(temp_df['end_of_over'],temp_df['win'],color='#00a65a',linewidth=4)
plt.plot(temp_df['end_of_over'],temp_df['lose'],color='red',linewidth=4)
plt.bar(temp_df['end_of_over'],temp_df['runs_after_over'])
plt.title('Target-' + str(target))

delivery_df['city'].unique()

teams

import pickle
pickle.dump(pipe,open('pipe.pkl','wb'))

X_train

"""##   Code Link :- https://github.com/iminsgineark/IPL-Match-Predictor-"""